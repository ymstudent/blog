---
title: "redis数据结构之压缩列表"
date: 2020-12-25T22:26:22+08:00
draft: false
tags: ["redis"]
keywords: ["redis", "设计与实现", "压缩列表", "zipList"]
---

压缩列表是列表键和哈希键的底层实现之一。**它是 redis 为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构**。

### 压缩列表的实现

一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。

压缩列表的构成：| zlbtypes | zltail | zllen | entry1 | .... | entryN | zlend |

压缩列表各组成部分详细说明：

| 属性    | 类型     | 长度   | 用途                                                         |
| ------- | -------- | ------ | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节  | 记录整个压缩列表占用的内存字节数，对压缩列表进行内存重分配或者是计算 zlend 的位置时使用 |
| zltail  | uint32_t | 4字节  | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，程序可以无需遍历整个列表就能确定表尾节点的地址 |
| zllen   | uint16_t | 2字节  | 记录压缩列表包含节点的数量，如果这个值等于 UINT16_MAX(65535) 时，需要遍历整个列表才能计算出真实节点数 |
| entryX  | 列表节点 | 不确定 | 压缩列表包含的节点                                           |
| zlend   | uint8_t  | 1字节  | 特殊值 0XFF(255)，用于标记压缩列表的末端                     |

压缩列表节点的的构成：| previous_entry_length | encoding | content |

节点组成部分详细说明：

| 属性                  | 长度                | 用途                                                         |
| --------------------- | ------------------- | ------------------------------------------------------------ |
| previous_entry_length | 1字节或5字节        | 记录前一个节点的长度，使程序可以通过当前节点的起始地址来计算出前一个节点的起始地址。如果前一节长度小于 254 字节，那么 previous_entry_length 的长度为 1 字节，否则长度为 5 字节 |
| encoding              | 1字节，2字节或5字节 | 记录节点 content 属性保存的数据的类型以及长度                |
| content               | 不确定              | 保存节点的值，可以使一个字节数组或一个整数值                 |

### 连锁更新

假设一个极端情况：在一个压缩列表的中，有多个连续的，长度为 250 字节到 253 字节的节点 e1 到 eN，此时所有节点的  previous_entry_length 都为 1 字节。

如果我们将一个长度大于 254 字节的新节点 new 设为表头，那么 new 将成为 e1 的前置节点，这时候因为 e1 的 previous_entry_length 仅为 1 个字节，导致没办法保存新节点的长度，所以程序将对压缩列表执行空间重分配操作，将 e1 的 previous_entry_length 属性从1字节扩展为 5 字节。

现在问题出现了，因为 previous_entry_length 扩展为 5 字节，e1 的长度变为了 254 字节至 257 字节，所以 e2 的 previous_entry_length 属性也必须有进行扩展操作了，以此类推 e3 到 eN ，所有的节点都必须进行内存重分配。

我们将这种在特殊情况下产生的连续多次空间扩展的操作称为“连锁更新”。添加和删除操作都可能会引发连锁更新。

因为连锁更新最坏的情况下需要对压缩列表执行 N 次空间重分配操作，而每次空间重分配操作的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为 O ( N^2 )。

虽然连锁更新的复杂度较高，但考虑到连续出现非常多的节点进行连锁更新的几率是很低的，所以基本上不用担心连锁更新会影响压缩列表的性能。

### 压缩列表的优点与缺点

压缩列表的存储在一块连续的内存上，所以存储效率很高。但它不利与修改操作，插入和删除需要频繁申请和释放内存，特别是当压缩列表上的特别长时，一次内存重分配操作可能导致大批量的数据拷贝（连锁更新）。