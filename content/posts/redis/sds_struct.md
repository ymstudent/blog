---
title: "redis数据结构之简单动态字符串"
date: 2020-12-12T22:43:39+08:00
draft: false
tags: ["redis"]
keywords: ["redis", "SDS", "设计与实现"]
---

简单动态字符串（Simple Dynamic String）: 简称SDS, 是redis默认的字符串表示，除了用来保存数据库中的字符串值外，还被用作缓冲区（buffer），eg: AOF缓冲区，客户端的输入缓冲区

### SDS的结构

```
struct sdshdr {
​	//记录buf数组中已使用字节的数量，等于SDS所保存的字符串的长度
​	int len ;
​	//记录buf数组中未使用字节的数量
​	int free ;
​	//字节数组，用于保存字符串
​	char buf[] ;
}
```

### SDS结构相较于C字符串的优点
相比于C语言使用的字符串，SDS结构在安全性、效率以及功能方面都要更胜一筹。

#### * 常数复杂度获取字符串长度

C字符串并不记录自身的长度信息，所以想要获取一个C字符串的长度，程序必须遍历整个字符串，这个操作的复杂度为O(N)。

而SDS字符串在len属性中记录了自身的长度，所以获取一个SDS长度的复杂度为O(1)。

#### * 杜绝缓冲区溢出

C字符串在修改字符串内容时，需要手动对为字符串分配足够的内存，否则很容易发生缓冲区溢出（buff overflow）。而SDS结构完全杜绝了这种情况的发生：当SDS API对SDS进行修改时，API会首先检查SDS的free属性，看剩余空间否能满足修改所需要求，如果不满足API会自动将SDS的空间扩展至所需大小，然后再进行实际的修改操作

#### * 减少修改字符串带来的内存重分配次数

因为C字符串并未记录自身的长度，所以对于一个包含了N个字符的C字符串来说，其底层实现总是一个N+1字符长的数组。这导致每次增加或缩短一个C字符，程序总要对保存这个C字符的数组进行一次内存重分配操作：

* 对于增加字符串操作，在执行操作前，需要通过内存重分配来扩展底层数组的空间大小，否则很容易产生缓冲区溢出

* 对于缩短字符串操作，在执行操作后，需要通过内存重分配来释放字符串不再使用的那部分空间，否则很容易内存泄露

SDS通过未使用空间解除了字符串长度与底层数组间的关联，并通过空间预分配与惰性空间释放两种优化策略降低内存重分配次数。

* 空间预分配：对于增加字符串长度的操作，API会先检查SDS的未使用空间是否足够，如果不够程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。通过预分配策略，SDS将连续增长N次字符串所需的内存分配次数从必定N次降低为最多N次。

	* 如果修改后SDS的len属性将小于1MB，那么程序将会分配和len属性同样大小的未使用空间
	
	* 如果修改后SDS的len属性大于等于1MB，那么程序会分配1MB的未使用空间

* 惰性空间释放：对于缩短字符串的操作，程序并不使用内存重分配来回收缩短后多余的字节，而是通过free属性记录起来，并等待将来使用。当用户需要真正释放掉未使用空间时，可以调用sdsRemoveFreeSpace函数。

#### * 二进制安全

为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，**程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样**。

这也是我们将SDS的buf属性称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。

通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。

#### * 兼容部分C字符串函数

因为SDS和C字符串一样使用空字符 ( '\0' ) 结尾，所以可以使用一部分C字符串函数，eg: strcasecmp函数和strcat

